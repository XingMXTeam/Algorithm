# 007 BinarySearch

## Content

二分查找：惊人的查找速度。 0-999找一个数 最多需要10次就能找到。42亿个数据中用二分查找一个数据，最多需要比较 32 次。

时间复杂度:n n/2 n/4 ... 
n/2^k = 1结束查找 求得k=logn 也就是比较次数。 所以时间复杂度是O(logn)。对数时间复杂度。

常量时间复杂度有时候比对数时间复杂度还高，因为O(1)的1可能是一个比较大的数。

指数时间复杂度的算法在大规模数据面前是无效的。

二分查找的适用范围：
1 有序而且数组存储的
2 静态数据：不会有频繁的插入和删除操作（动态数据一般用二叉树？）
3 数据量太小的话，直接遍历不需要二分；数据量太大对内存有一定要求，因为申请的是连续空间。
二分查找一般都可以用散列表或者二叉树做，但是它们的内存要求更高。二分查找更适合用在“近似”查找问题。

比如：
查找第一个值等于给定值的元素
查找最后一个值等于给定值的元素
查找第一个大于等于给定值的元素
查找最后一个小于等于给定值的元素

如果你只是死记硬背这个写法，我敢保证，过不了几天，你就会全都忘光。

## Question

1. 求一个数的平方根”？要求精确到小数点后 6 位

2. 当我们想要查询 202.102.133.13 这个 IP 地址的归属地时，我们就在地址库中搜索，发现这个 IP 地址落在 [202.102.133.0, 202.102.133.255] 这个地址范围内，那我们就可以将这个 IP 地址范围对应的归属地“山东东营市”显示给用户了。

现在这个问题应该很简单了。如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。如何来排序呢？我们知道，IP 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。（最后一个小于等于给定值的元素）

数据库实现，单性能受限？

3. 如果有序数组是一个循环有序数组（循环有序数组是将一个有序数组切成两段，并交换位置得到引用块内容），比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法
[Search in Rotated Sorted Array - Medium](https://leetcode.com/problems/search-in-rotated-sorted-array/)


