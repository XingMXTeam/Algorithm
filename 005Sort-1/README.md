# 002 Sort - 1

## Content

稳定排序有什么用？
金额相同的订单 订单时间按照从小到大排列
可以先按订单时间排序然后再按照金额稳定排序。

### 冒泡排序
冒泡排序的最好的时间复杂度是O(n)
冒泡排序的最差时间复杂度是O(n^2)。当最初状态就是逆序的时候，每一个都需要和下一个比较。总比较次数(比较次数肯定大于交换次数，所以根据加法守则，只要计算比较次数就行)是
```
n*(n-1)/2
```
这个也是有序度。 
排序的过程就是逆序度变小的过程，最终达到满有序度。

冒泡的平均时间复杂度：加权平均期望时间复杂度，分析的时候要结合概率论的知识。
交换次数是一定的。定性分析法。平均的时间复杂度
```
n*(n-1)/4
```
是O(n^2)。

链表和数组实现比较次数一致，但是链表交换更复杂。（链表实现时间复杂度可能变大）

冒泡排序的优化方法：
1 当某次冒泡没有数据交换说明已排好序

是原地排序；稳定（相同可以不移动）；

### 插入排序
总的交换次数是一定的，就是逆序度。比较得次数不一定。

最好是已排好序。只需要遍历一遍。时间复杂度是O(n)。
最坏是逆序。需要大量移动元素。时间复杂度是O(n^2)。
因为每次插入操作时间复杂度是O(n)，遍历一遍，所以平均时间复杂度是O(n^2)。

插入排序用数组实现需要移动元素，而用链表实现不需要，但是链表最后可能需要倒置（链表实现时间复杂度可能变小）。

原地；稳定（只是移动）

优化：参考希尔排序

插入排序只有一个赋值操作，比冒泡排序更快。

### 选择排序

也有已排序和未排序。和插入排序不同的是每次都从未排序中找到最小值。

最好是O(n)
最坏和平均都是O(n^2)

原地；不稳定（因为有交换操作）


### 归并排序

递归的时间复杂度也是递归式表示：
```
T(n)=2*T(n/2)+n
```
通过迭代法得到通用式，然后假设T(n/2^k)=T(1)，得到k的值代入通用式。求得时间复杂度是O(nlogn)。
均摊和最坏最好的时间复杂度都是O(nlogn)。

空间复杂度不能用时间复杂度累加的方式，因为函数空间用完会释放。所以空间复杂度是O(n)。

不一定是原地排序，事实上一般都开辟了新空间。稳定

### 快速排序




## Question

1. [K Closest Points to Origin - Medium](https://leetcode.com/problems/k-closest-points-to-origin/)

2. [H-index - Medium](https://leetcode.com/problems/h-index/)

3. [Insertion Sort List - Medium](https://leetcode.com/problems/insertion-sort-list/)