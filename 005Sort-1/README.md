# 002 Sort - 1

## Content

稳定排序有什么用？
金额相同的订单 订单时间按照从小到大排列
可以先按订单时间排序然后再按照金额稳定排序。

何为哨兵？
哨兵的是某个元素或者节点。能够减少第二层循环的条件判断语句。

### 冒泡排序
冒泡排序的最好的时间复杂度是O(n)
冒泡排序的最差时间复杂度是O(n^2)。当最初状态就是逆序的时候，每一个都需要和下一个比较。总比较次数(比较次数肯定大于交换次数，所以根据加法守则，只要计算比较次数就行)是
```
n*(n-1)/2
```
这个也是有序度。 
排序的过程就是逆序度变小的过程，最终达到满有序度。

冒泡的平均时间复杂度：加权平均期望时间复杂度，分析的时候要结合概率论的知识。
交换次数是一定的。定性分析法。平均的时间复杂度
```
n*(n-1)/4
```
是O(n^2)。

链表和数组实现比较次数一致，但是链表交换更复杂。（链表实现时间复杂度可能变大）

冒泡排序的优化方法：
1 当某次冒泡没有数据交换说明已排好序

是原地排序；稳定（相同可以不移动）；

### 插入排序
总的交换次数是一定的，就是逆序度。比较得次数不一定。

最好是已排好序。只需要遍历一遍。时间复杂度是O(n)。
最坏是逆序。需要大量移动元素。时间复杂度是O(n^2)。
因为每次插入操作时间复杂度是O(n)，遍历一遍，所以平均时间复杂度是O(n^2)。

插入排序用数组实现需要移动元素，而用链表实现不需要，但是链表最后可能需要倒置（链表实现时间复杂度可能变小）。

原地；稳定（只是移动）

优化：参考希尔排序

插入排序只有一个赋值操作，比冒泡排序更快。

### 选择排序

也有已排序和未排序。和插入排序不同的是每次都从未排序中找到最小值。

最好是O(n)
最坏和平均都是O(n^2)

原地；不稳定（因为有交换操作）

以上比较，插入排序更优：因为稳定，原地，比冒泡快。

### 归并排序

递归的时间复杂度也是递归式表示：
```
T(n)=2*T(n/2)+n
```
通过迭代法得到通用式，然后假设T(n/2^k)=T(1)，得到k的值代入通用式。求得时间复杂度是O(nlogn)。
均摊和最坏最好的时间复杂度都是O(nlogn)。

空间复杂度不能用时间复杂度累加的方式，因为函数空间用完会释放。所以空间复杂度是O(n)。

不一定是原地排序，事实上一般都开辟了新空间。稳定

### 快速排序

递归的时间复杂度也是递归式表示：
```
T(n)=2*T(n/2)+n
```
前提是找到的中间元素比较均匀，刚好能对半划分。最好是O(nlogn)。最坏下是已排好序，
每次分区平均扫描n/2个元素，乘以n次分区，时间复杂度是O(n^2)。
平均时间复杂度？递归树
```
T(n)=T(9n/10)+T(1n/10)+n
```

原地；不稳定（涉及交换操作，交换后两个相同的元素可能顺序就不一样了 比如6 4 6 3 4）

优化快速排序：关键是分区点找的合理
1 三数取中 2 随机法
递归可能出现堆栈溢出，通过堆上模拟实现一个函数调用栈。

Glibc 中的 qsort()是如何实现的：
小数据量->归并排序，否则快速排序（三数取中法，堆模拟调用），快速排序过程中，当元素小于4时，用插入排序，因为
n^2不一定比nlogn小，在小数据量的情况。

以上比较：快速排序没有额外空间浪费，归并排序时间复杂度比较稳定。

### 堆排序

### 桶排序

根据数据范围划分多个桶。每个桶用快速排序。时间复杂度计算：
```
O(m*n/m*logn/m)=O(nlogn/m) 当桶的个数和要排序的元素接近,n==m时。时间复杂度为O(n)，否则就是O(nlogn)
```
使用于外部排序。
比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，
没办法一次性把 10GB 的数据都加载到内存中。这个时候该怎么办呢？

创建好几个文件，文件名是编号，通过扫描，将每个文件放入某个订单金额区间的数据，比如0-99，100-199。
然后逐个文件读到内存中用快速排序。最后按编号读取所有文件内容到一个文件中。

特殊情况：计数排序。简单来说就是桶内只放一个元素，省掉桶内排序的情况。

如果你所在的省有 50 万考生，如何通过成绩快速排序得出名次呢？
考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。

根据年龄给100万用户排序。

何为计数？
两个数组A,B A数组的下标（或者文件编号）是数据范围，A一开始存储的是每个数据的个数，然后对A累加求和。
B数组存放排序后的结果。因此计数排序也只适用数据范围小于数据量的情况，而且数据是非负整数。

### 基数排序

逐位比较，并且位之间要有递进关系。也就是高位如果更大，低位就不用比较。
每一位的数据范围不能太大，要能够用线性排序算法（桶排序，计数排序）排序

假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序？
```
O(11*n)时间复杂度
```
对于位数不一致的，可以用0补齐



## Question

1. [K Closest Points to Origin - Medium](https://leetcode.com/problems/k-closest-points-to-origin/)

2. [H-index - Medium](https://leetcode.com/problems/h-index/)

3. [Insertion Sort List - Medium](https://leetcode.com/problems/insertion-sort-list/)

4. 现在你有 10 个接口访问日志文件，每个日志文件大小约 300MB，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 10 个较小的日志文件，合并为 1 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有 1GB，你有什么好的解决思路，能“快速”地将这 10 个日志文件合并吗？

10个io流对10个文件。10个找到最小值（用桶排序。时间复杂度为O(n)或者建堆？？）。然后指向下一个。

5. 如何用快排思想在O(n)内查找第K大元素？
[Kth Largest Element in an Array - Medium](https://leetcode.com/problems/kth-largest-element-in-an-array/)

6. 假设我们现在需要对 D，a，F，B，c，A，z 这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为 a，c，z，D，F，B，A，这个如何来实现呢？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法，又该怎么解决呢？

桶排序。26个桶时间复杂度是O(n)


